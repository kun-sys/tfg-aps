import { ɵɵdefineInjectable, Injectable, EventEmitter, Component, Input, Output, Pipe, NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatFormFieldModule } from '@angular/material/form-field';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { DomSanitizer } from '@angular/platform-browser';

class NgxMatAutocompleteControlService {
    constructor() { }
}
NgxMatAutocompleteControlService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMatAutocompleteControlService_Factory() { return new NgxMatAutocompleteControlService(); }, token: NgxMatAutocompleteControlService, providedIn: "root" });
NgxMatAutocompleteControlService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NgxMatAutocompleteControlService.ctorParameters = () => [];

class NgxMatAutocompleteControlComponent {
    constructor() {
        this.appearance = 'outline';
        this.options = [];
        this.required = false;
        this.showDefaultSelect = false;
        this.disabled = false;
        this.showPlaceholder = true;
        // @Input() inputText = '';
        // @Input() reactiveForm = true;
        // @Input() modelName = true;
        this.selectionChange = new EventEmitter();
        this.propValueEvent = new EventEmitter();
        this.keyUp = false;
        this.filterList = [];
    }
    ngOnChanges(changes) {
        if (changes) {
            if (+this.value > 0 || this.value.length > 0) {
                this.tempValue = this.control.value;
                this.setItems('');
                setTimeout(() => {
                    this.control.setValue(this.tempValue);
                }, 0);
            }
        }
        if (changes && changes.disabled && changes.disabled.currentValue) {
            this.control.disable();
        }
        else {
            this.disabled = false;
            this.control.enable();
        }
    }
    ngOnInit() {
        if (this.options) {
            this.setItems('');
        }
    }
    keyUpFunction(event, value) {
        if (event.key === 'Enter' || event.key === 'Tab') {
            event.preventDefault();
            return false;
        }
        else {
            if (value) {
                const data = this.filterList.filter(e => e[this.refName].toLowerCase() === value.toLowerCase());
                if (data.length > 0) {
                    this.keyUp = true;
                }
                else {
                    this.keyUp = true;
                }
            }
            else {
                this.keyUp = false;
            }
            this.propValueEvent.emit({
                propertyName: this.control,
                // tslint:disable-next-line: object-literal-shorthand
                value: value
            });
        }
    }
    get displayDataFn() {
        const dataNew = (data) => {
            if (data == null || data === undefined || data === '') {
                return null;
            }
            else {
                if (this.filterList && this.filterList.length > 0) {
                    data = this.options.find(x => x[this.refId] === data);
                    if (data) {
                        return data[this.refName];
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        };
        return dataNew;
    }
    // Resource ..
    setItems(value) {
        if (!value) {
            this.assignResourceCopy();
        }
        if (value) {
            this.filterList = Object.assign([], this.options).filter(item => ((item[this.refName].toLowerCase().indexOf(value.toLowerCase()) > -1)));
        }
    }
    assignResourceCopy() {
        this.filterList = Object.assign([], this.options);
    }
    checkValidValue() {
        const value = this.control.value;
        if (value === '' || value == null) {
        }
        else if (this.keyUp) {
            this.control.setErrors({ incorrect: true });
        }
        else {
            this.control.setErrors(null);
        }
    }
    checVal(value) {
        if (this.showDefaultSelect === false) {
            const data = this.options.filter(e => e[this.refName].toLowerCase().trim() ===
                value.toLowerCase().trim());
            if (data.length > 0) {
                const datax = data[0];
                this.control
                    .setValue(datax[this.refId]);
                // this.selectionChange.emit({event:{option:datax[this.refId]}});
                this.keyUp = false;
            }
            this.checkValidValue();
        }
    }
    emitValues(event) {
        this.selectionChange.emit(event.option.value);
        this.propValueEvent.emit({
            propertyName: this.control,
            value: event.option.value
        });
    }
}
NgxMatAutocompleteControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-mat-autocomplete-control',
                template: "  <mat-form-field [appearance]=\"appearance\" style=\"width: 100%;\">\r\n    <mat-label>{{label}} </mat-label>\r\n    <input #inputvalue  matInput [placeholder]=\"showPlaceholder?label:''\" \r\n     [matAutocomplete]=\"autoCmpt\" [formControl]=\"control\" \r\n      (focus)=\"setItems(inputvalue.value)\" (keypress)=\"keyUpFunction($event, inputvalue.value)\"\r\n      (input)=\"setItems(inputvalue.value)\"\r\n       (blur)=\"checVal(inputvalue.value);\" (click)=\"inputvalue.select()\"\r\n      [required]=\"required\" />\r\n  \r\n    <mat-error *ngIf=\"control?.errors?.required && required\">\r\n      {{label}} is required\r\n    </mat-error>\r\n    <mat-error *ngIf=\"control?.errors?.incorrect\">\r\n      {{label}} is not valid.\r\n    </mat-error>\r\n  \r\n    <mat-autocomplete #autoCmpt=\"matAutocomplete\" [displayWith]=\"displayDataFn\"\r\n     (optionSelected)=\"emitValues($event)\">\r\n      <!-- <mat-option>-------Select {{label}}-------</mat-option> -->\r\n      <mat-option [value]=\"data[refId]\" *ngFor=\"let data of filterList\" class=\"autocom-option autocom-tr\">\r\n        <span [innerHTML]=\"data[refName] | highlight: inputvalue.value \"></span>\r\n      </mat-option>\r\n      <mat-option *ngIf=\"filterList.length == 0\">\r\n        <div class=\"no-record\"><span>No Data Found</span></div>\r\n      </mat-option>\r\n    </mat-autocomplete>\r\n  \r\n  </mat-form-field>",
                styles: [".no-record{color:#78797b;font-size:14px;font-weight:300;line-height:.5;margin:.5rem 0;padding:30px 20px}.no-record span:after,.no-record span:before{border-bottom:1px solid rgba(0,0,0,.1);border-top:1px solid rgba(0,0,0,.1);content:\"\";display:inline-block;height:3px;position:relative;top:-2px;width:20px}.no-record span:before{margin-right:5px}.no-record span:after{margin-left:5px}.mat-option-text b{color:#3f51b5}"]
            },] }
];
NgxMatAutocompleteControlComponent.ctorParameters = () => [];
NgxMatAutocompleteControlComponent.propDecorators = {
    control: [{ type: Input }],
    refId: [{ type: Input }],
    refName: [{ type: Input }],
    label: [{ type: Input }],
    appearance: [{ type: Input }],
    options: [{ type: Input }],
    required: [{ type: Input }],
    showDefaultSelect: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    showPlaceholder: [{ type: Input }],
    selectionChange: [{ type: Output }],
    propValueEvent: [{ type: Output }]
};

class HighlightPipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(text, search) {
        if (search && text) {
            let pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((t) => {
                return t.length > 0;
            }).join('|');
            const regex = new RegExp(pattern, 'gi');
            return this.sanitizer.bypassSecurityTrustHtml(String(text).replace(regex, (match) => `<b>${match}</b>`));
        }
        else {
            return text;
        }
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'highlight'
            },] }
];
HighlightPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

class NgxMatAutocompleteControlModule {
}
NgxMatAutocompleteControlModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxMatAutocompleteControlComponent, HighlightPipe],
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    MatAutocompleteModule,
                    MatInputModule,
                    MatSelectModule,
                    MatFormFieldModule,
                    BrowserAnimationsModule
                ],
                exports: [NgxMatAutocompleteControlComponent,
                    FormsModule,
                    ReactiveFormsModule,
                    MatAutocompleteModule,
                    MatInputModule,
                    MatSelectModule,
                    MatFormFieldModule,
                    BrowserAnimationsModule]
            },] }
];

/*
 * Public API Surface of ngx-mat-autocomplete-control
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMatAutocompleteControlComponent, NgxMatAutocompleteControlModule, NgxMatAutocompleteControlService, HighlightPipe as ɵa };
//# sourceMappingURL=ngx-mat-autocomplete-control.js.map
