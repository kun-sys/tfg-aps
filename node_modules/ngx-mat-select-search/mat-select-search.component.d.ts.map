{"version":3,"file":"mat-select-search.component.d.ts","sources":["mat-select-search.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\n * Copyright (c) 2018 Bithost GmbH All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit, QueryList } from '@angular/core';\nimport { ControlValueAccessor, FormControl } from '@angular/forms';\nimport { MatOption } from '@angular/material/core';\nimport { MatSelect } from '@angular/material/select';\nimport { MatFormField } from '@angular/material/form-field';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { LiveAnnouncer } from '@angular/cdk/a11y';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { MatSelectSearchClearDirective } from './mat-select-search-clear.directive';\n/**\n * Component providing an input field for searching MatSelect options.\n *\n * Example usage:\n *\n * interface Bank {\n *  id: string;\n *  name: string;\n * }\n *\n * @Component({\n *   selector: 'my-app-data-selection',\n *   template: `\n *     <mat-form-field>\n *       <mat-select [formControl]=\"bankCtrl\" placeholder=\"Bank\">\n *         <mat-option>\n *           <ngx-mat-select-search [formControl]=\"bankFilterCtrl\"></ngx-mat-select-search>\n *         </mat-option>\n *         <mat-option *ngFor=\"let bank of filteredBanks | async\" [value]=\"bank.id\">\n *           {{bank.name}}\n *         </mat-option>\n *       </mat-select>\n *     </mat-form-field>\n *   `\n * })\n * export class DataSelectionComponent implements OnInit, OnDestroy {\n *\n *   // control for the selected bank\n *   public bankCtrl: FormControl = new FormControl();\n *   // control for the MatSelect filter keyword\n *   public bankFilterCtrl: FormControl = new FormControl();\n *\n *   // list of banks\n *   private banks: Bank[] = [{name: 'Bank A', id: 'A'}, {name: 'Bank B', id: 'B'}, {name: 'Bank C', id: 'C'}];\n *   // list of banks filtered by search keyword\n *   public filteredBanks: ReplaySubject<Bank[]> = new ReplaySubject<Bank[]>(1);\n *\n *   // Subject that emits when the component has been destroyed.\n *   private _onDestroy = new Subject<void>();\n *\n *\n *   ngOnInit() {\n *     // load the initial bank list\n *     this.filteredBanks.next(this.banks.slice());\n *     // listen for search field value changes\n *     this.bankFilterCtrl.valueChanges\n *       .pipe(takeUntil(this._onDestroy))\n *       .subscribe(() => {\n *         this.filterBanks();\n *       });\n *   }\n *\n *   ngOnDestroy() {\n *     this._onDestroy.next();\n *     this._onDestroy.complete();\n *   }\n *\n *   private filterBanks() {\n *     if (!this.banks) {\n *       return;\n *     }\n *\n *     // get the search keyword\n *     let search = this.bankFilterCtrl.value;\n *     if (!search) {\n *       this.filteredBanks.next(this.banks.slice());\n *       return;\n *     } else {\n *       search = search.toLowerCase();\n *     }\n *\n *     // filter the banks\n *     this.filteredBanks.next(\n *       this.banks.filter(bank => bank.name.toLowerCase().indexOf(search) > -1)\n *     );\n *   }\n * }\n */\nexport declare class MatSelectSearchComponent implements OnInit, OnDestroy, ControlValueAccessor {\n    matSelect: MatSelect;\n    changeDetectorRef: ChangeDetectorRef;\n    private _viewportRuler;\n    matOption: MatOption;\n    private liveAnnouncer;\n    matFormField: MatFormField;\n    /** Label of the search placeholder */\n    placeholderLabel: string;\n    /** Type of the search input field */\n    type: string;\n    /** Label to be shown when no entries are found. Set to null if no message should be shown. */\n    noEntriesFoundLabel: string;\n    /**\n     *  Text that is appended to the currently active item label announced by screen readers,\n     *  informing the user of the current index, value and total options.\n     *  eg: Bank R (Germany) 1 of 6\n    */\n    indexAndLengthScreenReaderText: string;\n    /**\n      * Whether or not the search field should be cleared after the dropdown menu is closed.\n      * Useful for server-side filtering. See [#3](https://github.com/bithost-gmbh/ngx-mat-select-search/issues/3)\n      */\n    clearSearchInput: boolean;\n    /** Whether to show the search-in-progress indicator */\n    searching: boolean;\n    /** Disables initial focusing of the input field */\n    disableInitialFocus: boolean;\n    /** Enable clear input on escape pressed */\n    enableClearOnEscapePressed: boolean;\n    /**\n     * Prevents home / end key being propagated to mat-select,\n     * allowing to move the cursor within the search input instead of navigating the options\n     */\n    preventHomeEndKeyPropagation: boolean;\n    /** Disables scrolling to active options when option list changes. Useful for server-side search */\n    disableScrollToActiveOnOptionsChanged: boolean;\n    /** Adds 508 screen reader support for search box */\n    ariaLabel: string;\n    /** Whether to show Select All Checkbox (for mat-select[multi=true]) */\n    showToggleAllCheckbox: boolean;\n    /** select all checkbox checked state */\n    toggleAllCheckboxChecked: boolean;\n    /** select all checkbox indeterminate state */\n    toggleAllCheckboxIndeterminate: boolean;\n    /** Display a message in a tooltip on the toggle-all checkbox */\n    toggleAllCheckboxTooltipMessage: string;\n    /** Define the position of the tooltip on the toggle-all checkbox. */\n    toogleAllCheckboxTooltipPosition: 'left' | 'right' | 'above' | 'below' | 'before' | 'after';\n    /** Show/Hide the search clear button of the search input */\n    hideClearSearchButton: boolean;\n    /**\n     * Always restore selected options on selectionChange for mode multi (e.g. for lazy loading/infinity scrolling).\n     * Defaults to false, so selected options are only restored while filtering is active.\n     */\n    alwaysRestoreSelectedOptionsMulti: boolean;\n    /** Output emitter to send to parent component with the toggle all boolean */\n    toggleAll: EventEmitter<boolean>;\n    /** Reference to the search input field */\n    searchSelectInput: ElementRef;\n    /** Reference to the search input field */\n    innerSelectSearch: ElementRef;\n    /** Reference to custom search input clear icon */\n    clearIcon: MatSelectSearchClearDirective;\n    readonly isInsideMatOption: boolean;\n    /** Current search value */\n    readonly value: string;\n    private _lastExternalInputValue;\n    onTouched: Function;\n    /** Reference to the MatSelect options */\n    _options: QueryList<MatOption>;\n    _options$: BehaviorSubject<QueryList<MatOption>>;\n    private optionsList$;\n    private optionsLength$;\n    /** Previously selected values when using <mat-select [multiple]=\"true\">*/\n    private previousSelectedValues;\n    _formControl: FormControl;\n    /** whether to show the no entries found message */\n    _showNoEntriesFound$: Observable<boolean>;\n    /** Subject that emits when the component has been destroyed. */\n    private _onDestroy;\n    constructor(matSelect: MatSelect, changeDetectorRef: ChangeDetectorRef, _viewportRuler: ViewportRuler, matOption: MatOption, liveAnnouncer: LiveAnnouncer, matFormField?: MatFormField);\n    ngOnInit(): void;\n    _emitSelectAllBooleanToParent(state: boolean): void;\n    ngOnDestroy(): void;\n    _isToggleAllCheckboxVisible(): boolean;\n    /**\n     * Handles the key down event with MatSelect.\n     * Allows e.g. selecting with enter key, navigation with arrow keys, etc.\n     * @param event\n     */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Handles the key up event with MatSelect.\n     * Allows e.g. the announcing of the currently activeDescendant by screen readers.\n     */\n    _handleKeyup(event: KeyboardEvent): void;\n    /**\n     * Calculate the index of the current option, taking the offset to length into account.\n     * examples:\n     *    Case 1 [Search, 1, 2, 3] will have offset of 1, due to search and will read index of total.\n     *    Case 2 [1, 2, 3] will have offset of 0 and will read index +1 of total.\n     */\n    getAriaIndex(optionIndex: number): number;\n    /**\n     * Calculate the length of the options, taking the offset to length into account.\n     * examples:\n     *    Case 1 [Search, 1, 2, 3] will have length of options.length -1, due to search.\n     *    Case 2 [1, 2, 3] will have length of options.length.\n     */\n    getAriaLength(): number;\n    writeValue(value: string): void;\n    onBlur(): void;\n    registerOnChange(fn: (value: string) => void): void;\n    registerOnTouched(fn: Function): void;\n    /**\n     * Focuses the search input field\n     */\n    _focus(): void;\n    /**\n     * Resets the current search value\n     * @param focus whether to focus after resetting\n     */\n    _reset(focus?: boolean): void;\n    /**\n     * Initializes handling <mat-select [multiple]=\"true\">\n     * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.\n     */\n    private initMultipleHandling;\n    /**\n     * Scrolls the currently active option into the view if it is not yet visible.\n     */\n    private adjustScrollTopToFitActiveOptionIntoView;\n    /**\n     *  Set the width of the innerSelectSearch to fit even custom scrollbars\n     *  And support all Operation Systems\n     */\n    updateInputWidth(): void;\n    private getMatOptionHeight;\n    /**\n     * Determine the offset to length that can be caused by the optional matOption used as a search input.\n     */\n    private getOptionsLengthOffset;\n}\n"]}